---
title: 随笔
date: 2024-02-25 12:28:27
tags:
published: false
hidden: true
---

## 20240715
1. 做算法题的时候，经常会出现这样一个问题，前面的思路是正确的，但是总会在中间某一步卡住无法继续下去。
> 把前面的思路用代码或者用纸笔实现出来，看看效果，然后再顺着这个思路继续往下想。在不确定已经有的思路是否正确时，可以举例子或者用数学方法证明之，或者用反例证伪。而当你无法证明它是错的时候，它就很可能是对的，你要做的就是顺着思路把完整的解法写出来，然后用题目的用例去判定即可。切记不要停滞不前！！！

## 20240804
### ReentrantLock实现公平锁和非公平锁的方式

**非公平锁：**

```java
// ReentrantLock.java

abstract static class Sync extends AbstractQueuedSynchronizer{

    final boolean nonfairTryAcquire(int acquires){
        final Thread current = Thread.currentThread();
        int c = getState();
        if(c==0){   //可以去竞争锁
            //不管现在有没有其它线程在等待这把锁，直接去竞争锁
            if(compareAndSetState(0,acquires)){
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current==getExclusiveOwerThread()){
            int nextc = c + acquires;
            if (nextc<0){
                throw new Error("Maxium lock count exceeded");
            }
            setState(nextc);
            return true;
        }

        return false;
    }

}

```

**公平锁：**

```java
// ReentrantLock.java //state=0表示没有被加锁，说明它是一把互斥锁
static final class FairSync extends Sync{

protected final boolean tryAcquire(int acquires){
    final Thread current = Thread.currentThread();//获取当前线程
    // 获取共享变量的值
    int c = getState();
    if(c==0){// 没有被加锁
        // 有两种情况：1.CLH队列为空，2.CLH队列的第一个排队线程是当前线程，则尝试获取锁
        if(!hasQueuedPredecessors()&&compareAndStetState(0,acquires)){
            setExclusiveOwerThread(current);  //设置为当前线程独占
            return true;
        }
    }
    else if(current==getExclusiveOwnerThread()){ //已经被加锁，但是加锁的线程是当前线程
        int nextc = c+acquires;
        if(nextc<0){    //重入次数溢出
            throw new Error("Maximum lock count exceeded");
        }
        setState(nextc);
        return true;
    }
    //已经被其它线程加锁，或者有其它线程在等待锁，则加锁失败
    return false;

}

}

```

**总结：**  
公平锁：当可以竞争锁时，当前线程会判断是不是自己先等待锁的，若不是则进入等待队列。  
非公平锁：当可以竞争锁时，不管前面是否有线程在等待锁，当前线程都会去尝试获取一次锁。